Works with values on a stack.
Also has a callstack.
Variables are also held in contexts that have access to their parents.
The functions are initialized with the stack they were made in.

*An operand is a command which pops 2 values off the stack and pushes
    back a result based on those values

INT(n) -> pushes an int to the stack
FLT(f) -> pushes a float to the stack
STR(s) -> pushes a string to the stack
TRUE -> pushes a "true" boolean to the stack
FALSE -> pushes a "false" boolean to the stack
RANGE -> pushes a range to the stack, based on the 3 top values already there
    -> step (top)
    -> end
    -> start
NIL -> pushes a nil value to the stack

FUNCTION(next, minArgCount, argCount, isFinalArgSpread) -> pushes a function to the stack, taking the name of the top
                      string on the stack (push nil if no name), the function's
                      code being placed immediately after the command, then jump
                      to 'next'

JMP(location) -> jump to said location.
SKP -> skip the next command if the top value on the stack is truthy (popping it).
NSKP -> equivalent to BNOT SKIP.

BNOT -> pop the top value and push it's reverse truthy value
BOOL -> pop the top value and push it's truthy value
BOR -> command, returns whether any one of the values is truthy
BAND -> command, returns whether both of the values are truthy

EQ -> command, returns whether the 2 values are equal
LT -> command, returns whether the first value is less than the other
GT -> command, returns whether the first value is greater than the other

GET(varId, level) -> gets the value from a variable and pushes it on the stack
SET(varId, level) -> pops a value from the stack and stores the value in said variable
VAR(varId, level) -> pushes 'true' when the variable exists, 'false' when not
NOTE: the previous 3 commands have, the level is a positive integer saying how many levels to go
      up stack to find the variable (0 is current context)
      also notice how the byte code does not care about silly things like variable redefinition
      or constants.
      instead, it's the transpiler's job to yell at you when you do dumb stuff
      like trying to redefine a constant.
      it also needs to figure out how many levels up to get the variable since doing
      that at runtime will get us to sub-python levels.

PUSH, POP -> manage contexts (you can guess what they do)

ARGUMENTS -> pushes an ARGUMENTS object to the stack, only to act as a delimiter for CALL
CALL -> it's better to show by example:
    stack:
        (some function)
        ARGUMENTS
        0
        1
    step 1: get arguments (delimited by the ARGUMENTS object)
        NOTE: the arguments are placed in reverse order due to the way the stack works
    stack:
        (some function)
    step 2: call the function with said arguments, also making sure
        to push a new context
    step 3:
        after the function returns, go to the next command

RETURN -> end a function's execution.
        NOTE: the return value of the function must be placed on the top of the stack
              and there must be no other values at the time of returning.
              If you just want to exit the function, you still need to have
              some return value, so do:
                NIL
                RETURN
              to exit

ADD, SUB, MUL, DIV -> commands, do the things you expect them to
UMN -> unary minus
REM -> pop a value from the stack and do nothing with it
NOP -> no-op

(not yet implemented)
GETATTR(attrName), SETATTR(attrName) -> do what you expect
       (SETATTR expects the value on top of the stack and the value below it)

(not yet implemented)
GETIDX, SETIDX -> also do what you expect (value, index, value (for SETIDX))

DUP -> duplicates the top value of the stack
